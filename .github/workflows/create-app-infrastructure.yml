name: Create App Team Infrastructure Repository

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Application name (e.g., my-web-app)'
        required: true
        type: string
      
      target_github_org:
        description: 'Target GitHub organization for app team'
        required: true
        type: string
      
      app_team_contacts:
        description: 'App team contact emails (comma-separated)'
        required: true
        type: string
      
      aws_accounts:
        description: 'AWS Account IDs (format: dev:123456789012,staging:123456789013,prod:123456789014)'
        required: true
        type: string
      
      staging_approvers:
        description: 'GitHub usernames for staging approvals (comma-separated)'
        required: true
        type: string
      
      prod_approvers:
        description: 'GitHub usernames for production approvals (comma-separated)'
        required: true
        type: string
      
      aws_region:
        description: 'Primary AWS region'
        required: false
        type: choice
        default: 'us-east-1'
        options:
          - 'us-east-1'
          - 'us-west-2'
          - 'eu-west-1'
          - 'ap-southeast-1'

  # API trigger support
  repository_dispatch:
    types: [create-app-infrastructure]

env:
  REPO_NAME: "${{ github.event.inputs.app_name || github.event.client_payload.app_name }}-infrastructure"
  TARGET_ORG: "${{ github.event.inputs.target_github_org || github.event.client_payload.target_github_org }}"
  APP_NAME: "${{ github.event.inputs.app_name || github.event.client_payload.app_name }}"

jobs:
  validate-inputs:
    name: Validate Inputs
    runs-on: ubuntu-latest
    outputs:
      app_name: ${{ steps.validate.outputs.app_name }}
      repo_name: ${{ steps.validate.outputs.repo_name }}
      target_org: ${{ steps.validate.outputs.target_org }}
      dev_account_id: ${{ steps.validate.outputs.dev_account_id }}
      staging_account_id: ${{ steps.validate.outputs.staging_account_id }}
      prod_account_id: ${{ steps.validate.outputs.prod_account_id }}
      staging_approvers: ${{ steps.validate.outputs.staging_approvers }}
      prod_approvers: ${{ steps.validate.outputs.prod_approvers }}
      aws_region: ${{ steps.validate.outputs.aws_region }}
      
    steps:
      - name: Validate and normalize inputs
        id: validate
        run: |
          # Get inputs from either workflow_dispatch or repository_dispatch
          APP_NAME="${{ github.event.inputs.app_name || github.event.client_payload.app_name }}"
          TARGET_ORG="${{ github.event.inputs.target_github_org || github.event.client_payload.target_github_org }}"
          AWS_ACCOUNTS="${{ github.event.inputs.aws_accounts || github.event.client_payload.aws_accounts }}"
          STAGING_APPROVERS="${{ github.event.inputs.staging_approvers || github.event.client_payload.staging_approvers }}"
          PROD_APPROVERS="${{ github.event.inputs.prod_approvers || github.event.client_payload.prod_approvers }}"
          AWS_REGION="${{ github.event.inputs.aws_region || github.event.client_payload.aws_region || 'us-east-1' }}"
          
          # Debug: Show raw inputs
          echo "🔍 Debug - Raw inputs:"
          echo "AWS_ACCOUNTS: '$AWS_ACCOUNTS'"
          echo "STAGING_APPROVERS: '$STAGING_APPROVERS'"
          echo "PROD_APPROVERS: '$PROD_APPROVERS'"
          
          # Parse AWS accounts (format: dev:123456789012,staging:123456789013,prod:123456789014)
          DEV_ACCOUNT=$(echo "$AWS_ACCOUNTS" | grep -oE 'dev:[0-9]{12}' | cut -d: -f2)
          STAGING_ACCOUNT=$(echo "$AWS_ACCOUNTS" | grep -oE 'staging:[0-9]{12}' | cut -d: -f2)
          PROD_ACCOUNT=$(echo "$AWS_ACCOUNTS" | grep -oE 'prod:[0-9]{12}' | cut -d: -f2)
          
          # Debug: Show parsed values
          echo "🔍 Debug - Parsed values:"
          echo "DEV_ACCOUNT: '$DEV_ACCOUNT'"
          echo "STAGING_ACCOUNT: '$STAGING_ACCOUNT'"
          echo "PROD_ACCOUNT: '$PROD_ACCOUNT'"
          echo "STAGING_APPROVERS: '$STAGING_APPROVERS'"
          echo "PROD_APPROVERS: '$PROD_APPROVERS'"
          
          # Validate app name format
          if [[ ! "$APP_NAME" =~ ^[a-z0-9-]+$ ]]; then
            echo "❌ App name must contain only lowercase letters, numbers, and hyphens"
            exit 1
          fi
          
          # Validate AWS account IDs
          for account in "$DEV_ACCOUNT" "$STAGING_ACCOUNT" "$PROD_ACCOUNT"; do
            if [[ ! "$account" =~ ^[0-9]{12}$ ]]; then
              echo "❌ Invalid AWS account ID format: $account (must be 12 digits)"
              exit 1
            fi
          done
          
          # Generate repository name
          REPO_NAME="${APP_NAME}-infrastructure"
          
          # Set outputs
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "target_org=$TARGET_ORG" >> $GITHUB_OUTPUT
          echo "dev_account_id=$DEV_ACCOUNT" >> $GITHUB_OUTPUT
          echo "staging_account_id=$STAGING_ACCOUNT" >> $GITHUB_OUTPUT
          echo "prod_account_id=$PROD_ACCOUNT" >> $GITHUB_OUTPUT
          echo "staging_approvers=$STAGING_APPROVERS" >> $GITHUB_OUTPUT
          echo "prod_approvers=$PROD_APPROVERS" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT
          
          echo "✅ Input validation completed"
          echo "📋 App Name: $APP_NAME"
          echo "📋 Repository: $TARGET_ORG/$REPO_NAME"
          echo "📋 AWS Accounts: Dev($DEV_ACCOUNT), Staging($STAGING_ACCOUNT), Prod($PROD_ACCOUNT)"

  create-repository:
    name: Create GitHub Repository
    runs-on: ubuntu-latest
    needs: validate-inputs
    outputs:
      repository_url: ${{ steps.create-repo.outputs.repository_url }}
      clone_url: ${{ steps.create-repo.outputs.clone_url }}
      
    steps:
      - name: Checkout platform repository
        uses: actions/checkout@v4
        
      - name: Setup GitHub CLI
        run: |
          gh --version
          echo "${{ secrets.PLATFORM_GITHUB_TOKEN }}" | gh auth login --with-token
          
      - name: Check if repository exists
        id: check-repo
        run: |
          if gh repo view "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "⚠️ Repository already exists: ${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "✅ Repository name is available"
          fi
          
      - name: Create GitHub repository
        id: create-repo
        if: steps.check-repo.outputs.exists == 'false'
        run: |
          # Create repository
          gh repo create "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" \
            --description "Infrastructure as Code for ${{ needs.validate-inputs.outputs.app_name }}" \
            --private \
            --clone=false
          
          # Set outputs
          REPO_URL="https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          CLONE_URL="git@github.com:${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git"
          
          echo "repository_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "clone_url=$CLONE_URL" >> $GITHUB_OUTPUT
          
          echo "✅ Repository created: $REPO_URL"
          
      - name: Handle existing repository
        if: steps.check-repo.outputs.exists == 'true'
        run: |
          echo "⚠️ Repository already exists. Skipping creation."
          echo "📋 Existing repository: https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          
          # Set outputs for existing repo
          REPO_URL="https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          CLONE_URL="git@github.com:${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git"
          
          echo "repository_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "clone_url=$CLONE_URL" >> $GITHUB_OUTPUT

  setup-repository-structure:
    name: Setup Repository Structure
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-repository]
    
    steps:
      - name: Checkout base infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: rajamuthuns/terraform-infra-orchestrator-enhanced
          path: base-repo
        

          
      - name: Clone target repository
        run: |
          echo "${{ secrets.PLATFORM_GITHUB_TOKEN }}" | gh auth login --with-token
          gh repo clone "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" target-repo
          cd target-repo
          
          # Configure Git to use the token for authentication
          git config --global credential.helper store
          echo "https://x-access-token:${{ secrets.PLATFORM_GITHUB_TOKEN }}@github.com" > ~/.git-credentials
          git config --global user.name "Platform Engineering Bot"
          git config --global user.email "platform-engineering@company.com"
          
      - name: Setup main branch (minimal)
        run: |
          cd target-repo
          
          # Copy only essential files to main branch
          cp ../base-repo/.gitignore .
          
          # Copy GitHub workflows
          mkdir -p .github/workflows
          cp -r ../base-repo/.github/workflows/* .github/workflows/
          
          echo "✅ Main branch setup completed (minimal files only)"
          

          

          
      - name: Copy main workspace README and create app-specific README
        run: |
          cd target-repo
          
          # Copy the main workspace README.md as PLATFORM-README.md for reference
          cp ../base-repo/README.md PLATFORM-README.md
          
          # Create app-specific README
          cat > README.md << EOF
          # ${{ needs.validate-inputs.outputs.app_name }} Infrastructure
          
          Infrastructure as Code for ${{ needs.validate-inputs.outputs.app_name }} using Terraform and GitOps workflow.
          
          ## 🏗️ Architecture
          
          This repository uses the Terraform Infrastructure Orchestrator pattern to manage infrastructure across multiple environments (dev, staging, production) with GitOps workflow.
          
          ### Environments
          - **Development**: Account ID ${{ needs.validate-inputs.outputs.dev_account_id }}
          - **Staging**: Account ID ${{ needs.validate-inputs.outputs.staging_account_id }}  
          - **Production**: Account ID ${{ needs.validate-inputs.outputs.prod_account_id }}
          
          ### Approvers
          - **Staging**: ${{ needs.validate-inputs.outputs.staging_approvers }}
          - **Production**: ${{ needs.validate-inputs.outputs.prod_approvers }}
          
          ## 🚀 Quick Start
          
          ### 1. Configure Your Infrastructure
          
          Create your environment-specific configuration files:
          
          \`\`\`bash
          # Copy example files and customize
          cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars
          cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars
          cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars
          
          # Edit each file with your specific requirements
          nano tfvars/dev-terraform.tfvars
          nano tfvars/stg-terraform.tfvars
          nano tfvars/prod-terraform.tfvars
          \`\`\`
          
          ### 2. Add User Data Scripts
          
          Create your server initialization scripts:
          
          \`\`\`bash
          # Copy example files and customize
          cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh
          # cp userdata/userdata-windows.ps1.example userdata/userdata-windows.ps1  # If needed
          
          # Edit scripts for your application
          nano userdata/userdata-linux.sh
          \`\`\`
          
          ### 3. Set Up AWS Credentials
          
          Configure GitHub repository secrets (see SETUP.md for details):
          - AWS_ACCESS_KEY_ID
          - AWS_SECRET_ACCESS_KEY
          - PRIVATE_REPO_TOKEN (for private modules)
          
          ### 4. Deploy with GitOps
          
          \`\`\`bash
          # Add all your configurations
          git add .
          git commit -m "feat: initial infrastructure configuration"
          git push origin dev
          
          # GitOps workflow will automatically:
          # 1. Deploy to dev environment
          # 2. Create PR to staging (requires approval)
          # 3. Create PR to production (requires approval)
          \`\`\`
          
          ## 🌍 Environments and Approvals
          
          - **Dev**: Auto-deploys on push to dev branch
          - **Staging**: Requires approval from: ${{ needs.validate-inputs.outputs.staging_approvers }}
          - **Production**: Requires approval from: ${{ needs.validate-inputs.outputs.prod_approvers }}
          
          ## 📁 Project Structure
          
          \`\`\`
          ${{ needs.validate-inputs.outputs.repo_name }}/
          ├── README.md                          # This file
          ├── PLATFORM-README.md                 # Complete platform documentation
          ├── SETUP.md                           # Detailed setup instructions
          ├── main.tf                            # Infrastructure orchestration
          ├── variables.tf                       # Variable definitions
          ├── outputs.tf                         # Output definitions
          ├── backend.tf                         # Backend configuration
          ├── tfvars/                            # Environment configurations
          │   ├── dev-terraform.tfvars           # Development config
          │   ├── stg-terraform.tfvars           # Staging config
          │   └── prod-terraform.tfvars          # Production config
          ├── userdata/                          # Server initialization scripts
          │   ├── userdata-linux.sh              # Linux initialization
          │   └── userdata-windows.ps1           # Windows initialization
          ├── .github/workflows/                 # GitOps CI/CD pipelines
          ├── config/                            # Environment configurations
          ├── shared/                            # Backend configurations
          ├── scripts/                           # Utility scripts
          └── docs/                              # Documentation
          \`\`\`
          
          ## 🛠️ Local Development
          
          \`\`\`bash
          # Plan changes for development
          ./deploy.sh dev plan
          
          # Apply changes to development
          ./deploy.sh dev apply
          
          # Plan changes for staging
          ./deploy.sh staging plan
          \`\`\`
          
          ## 📖 Documentation
          
          - [SETUP.md](SETUP.md) - Detailed setup instructions
          - [CREDENTIALS-SETUP.md](CREDENTIALS-SETUP.md) - AWS credentials setup guide
          - [PLATFORM-README.md](PLATFORM-README.md) - Complete platform documentation
          - [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) - Architecture details
          - [docs/TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md) - Common issues
          
          ## 🆘 Support
          
          For questions or issues:
          1. Check the SETUP.md file
          2. Review PLATFORM-README.md for complete documentation
          3. Review documentation in docs/ folder
          4. Contact the Platform Engineering team
          5. Create an issue in this repository
          
          ---
          
          **Repository created by Platform Engineering Pipeline**  
          **Creation Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")  
          **Platform Team**: Contact platform-engineering@company.com for support
          EOF
          
          echo "✅ App-specific README created and main workspace README copied"
          
      - name: Create comprehensive setup instructions
        run: |
          cd target-repo
          
          # Create comprehensive setup guide (embedded in workflow since platform repo is separate)
          cat > SETUP.md << 'SETUP_EOF'
          # Setup Instructions for App Team
          
          This guide will help you complete the setup of your infrastructure repository.
          
          ## 🎯 Overview
          
          Your infrastructure repository has been created with the following structure:
          - ✅ Base Terraform files copied
          - ✅ GitOps workflow configured
          - ✅ GitHub environments set up
          - ⚠️ **Action Required**: Configure tfvars and userdata
          - ⚠️ **Action Required**: Set up AWS credentials
          
          ## 📋 Required Actions
          
          ### 1. Configure Infrastructure (tfvars)
          
          Create your environment-specific configuration files:
          
          ```bash
          # Copy example files
          cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars
          cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars
          cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars
          ```
          
          **Key configurations to update:**
          
          #### In all tfvars files:
          - `gitlab_org` - Your GitLab organization name
          - `base_modules` - Module repositories and versions
          - VPC names (must match your existing VPCs)
          - Subnet names (must match your existing subnets)
          - Key pair names (must exist in your AWS accounts)
          
          #### Environment-specific values:
          - `instance_type` - Different sizes per environment
          - `root_volume_size` - Storage requirements
          - `ami_name` - AMI selection criteria
          - SSL certificates for production ALB
          
          ### 2. Create User Data Scripts
          
          Create server initialization scripts:
          
          ```bash
          # Copy example files
          cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh
          # cp userdata/userdata-windows.ps1.example userdata/userdata-windows.ps1  # If needed
          ```
          
          **Customize the scripts for your application:**
          - Install required software packages
          - Configure application settings
          - Set up monitoring and logging
          - Configure environment-specific settings
          
          ### 3. Set Up AWS Credentials
          
          Configure the following GitHub repository secrets:
          
          #### Go to: Repository Settings → Secrets and variables → Actions
          
          **Required Secrets:**
          ```
          AWS_ACCESS_KEY_ID          - AWS access key for deployments
          AWS_SECRET_ACCESS_KEY      - AWS secret key for deployments
          PRIVATE_REPO_TOKEN         - GitHub token for private module access
          ```
          
          **Optional Secrets:**
          ```
          GITLAB_TOKEN              - GitLab token if using GitLab modules
          SLACK_WEBHOOK_URL         - For deployment notifications
          ```
          
          ### 4. Test Your Setup
          
          **Step 1: Validate Configuration**
          ```bash
          # Check Terraform syntax
          terraform fmt -check
          terraform validate
          ```
          
          **Step 2: Test Development Deployment**
          ```bash
          # Switch to dev branch
          git checkout dev
          
          # Add your configurations
          git add tfvars/ userdata/
          git commit -m "feat: add initial infrastructure configuration"
          git push origin dev
          
          # Monitor GitHub Actions for deployment
          ```
          
          **Step 3: Verify Infrastructure**
          - Check AWS console for created resources
          - Verify EC2 instances are running
          - Test ALB endpoints
          - Check user data script execution logs
          
          ## 🚀 Deployment Workflow
          
          ### GitOps Workflow
          1. **Development**: Push to `dev` branch → Auto-deploy to dev environment
          2. **Staging**: Merge dev to `staging` → Requires team approval → Deploy to staging
          3. **Production**: Merge staging to `production` → Requires senior approval → Deploy to production
          
          ### Manual Deployment
          ```bash
          # Local development testing
          ./deploy.sh dev plan
          ./deploy.sh dev apply
          
          # Staging deployment
          ./deploy.sh staging plan
          ./deploy.sh staging apply
          
          # Production deployment (with confirmation)
          ./deploy.sh production plan
          ./deploy.sh production apply
          ```
          
          ## 🛡️ Security Best Practices
          
          ### Secrets Management
          - Never commit secrets to repository
          - Use AWS Systems Manager Parameter Store
          - Use AWS Secrets Manager for database passwords
          - Rotate credentials regularly
          
          ### Access Control
          - Use least privilege IAM policies
          - Enable MFA for AWS accounts
          - Restrict GitHub repository access
          - Use branch protection rules
          
          ## 🔍 Troubleshooting
          
          ### Common Issues
          
          **Terraform Backend Errors:**
          ```bash
          # Initialize backend
          terraform init -backend-config=shared/backend-dev.hcl
          
          # If backend doesn't exist, run setup
          ./scripts/setup-backend-per-account.sh
          ```
          
          **Module Download Failures:**
          - Check PRIVATE_REPO_TOKEN has access to module repositories
          - Verify module repository URLs in main.tf
          - Ensure module versions/tags exist
          
          **AWS Permission Errors:**
          - Verify AWS credentials in GitHub secrets
          - Check IAM policies have required permissions
          - Ensure cross-account roles are configured correctly
          
          **VPC/Subnet Not Found:**
          - Verify VPC and subnet names in tfvars files
          - Check that resources exist in target AWS accounts
          - Ensure Name tags match exactly
          
          ### Getting Help
          
          1. **Check Logs:**
             - GitHub Actions workflow logs
             - CloudWatch logs for EC2 instances
             - Terraform plan/apply output
          
          2. **Validate Configuration:**
             ```bash
             terraform fmt -check
             terraform validate
             terraform plan -var-file=tfvars/dev-terraform.tfvars
             ```
          
          3. **Contact Support:**
             - Create issue in this repository
             - Contact Platform Engineering team
             - Check PLATFORM-README.md for complete documentation
          
          ## 📚 Additional Resources
          
          - [Terraform Documentation](https://www.terraform.io/docs)
          - [AWS Provider Documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
          - [GitHub Actions Documentation](https://docs.github.com/en/actions)
          - [GitOps Best Practices](https://www.gitops.tech/)
          
          ---
          
          **Next Steps:**
          1. Complete the required actions above
          2. Test your development environment
          3. Set up monitoring and alerting
          4. Document your application-specific configurations
          5. Train your team on the GitOps workflow
          SETUP_EOF
          
          # Create credentials setup guide
          cat > CREDENTIALS-SETUP.md << 'CREDS_EOF'
          # AWS Credentials Setup Guide
          
          This guide explains how to set up AWS credentials for your infrastructure deployment pipeline.
          
          ## 🎯 Overview
          
          Your infrastructure needs AWS credentials to deploy resources across different environments. This guide covers multiple approaches from simple to enterprise-grade security.
          
          ## 🔐 Authentication Methods
          
          ### Method 1: IAM User with Access Keys (Simple)
          
          **Best for**: Small teams, development environments, getting started quickly
          
          #### Step 1: Create IAM User
          ```bash
          # Using AWS CLI (if you have admin access)
          aws iam create-user --user-name terraform-deployer
          
          # Attach PowerUser policy (or create custom policy)
          aws iam attach-user-policy \
              --user-name terraform-deployer \
              --policy-arn arn:aws:iam::aws:policy/PowerUserAccess
          ```
          
          #### Step 2: Create Access Keys
          ```bash
          # Create access key
          aws iam create-access-key --user-name terraform-deployer
          
          # Output will show:
          # AccessKeyId: AKIA...
          # SecretAccessKey: ...
          ```
          
          #### Step 3: Add to GitHub Secrets
          1. Go to your repository: `Settings` → `Secrets and variables` → `Actions`
          2. Add these secrets:
             - `AWS_ACCESS_KEY_ID`: Your access key ID
             - `AWS_SECRET_ACCESS_KEY`: Your secret access key
          
          ### Method 2: Cross-Account Roles (Recommended)
          
          **Best for**: Production environments, enterprise security, multiple AWS accounts
          
          Your backend configurations already reference OrganizationAccountAccessRole:
          
          ```hcl
          # shared/backend-dev.hcl
          role_arn = "arn:aws:iam::DEV-ACCOUNT-ID:role/OrganizationAccountAccessRole"
          
          # shared/backend-staging.hcl  
          role_arn = "arn:aws:iam::STAGING-ACCOUNT-ID:role/OrganizationAccountAccessRole"
          
          # shared/backend-prod.hcl
          role_arn = "arn:aws:iam::PROD-ACCOUNT-ID:role/OrganizationAccountAccessRole"
          ```
          
          ## 🔑 Required Permissions
          
          ### Minimum IAM Policy for Terraform
          
          ```json
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:*",
                  "elasticloadbalancing:*",
                  "autoscaling:*",
                  "cloudwatch:*",
                  "logs:*",
                  "iam:ListInstanceProfiles",
                  "iam:PassRole",
                  "s3:GetObject",
                  "s3:PutObject",
                  "s3:DeleteObject",
                  "s3:ListBucket",
                  "dynamodb:GetItem",
                  "dynamodb:PutItem",
                  "dynamodb:DeleteItem",
                  "dynamodb:DescribeTable"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "s3:CreateBucket",
                  "s3:DeleteBucket",
                  "s3:GetBucketVersioning",
                  "s3:PutBucketVersioning",
                  "s3:GetBucketEncryption",
                  "s3:PutBucketEncryption",
                  "s3:PutBucketPublicAccessBlock"
                ],
                "Resource": "arn:aws:s3:::terraform-state-*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "dynamodb:CreateTable",
                  "dynamodb:DeleteTable",
                  "dynamodb:DescribeTable"
                ],
                "Resource": "arn:aws:dynamodb:*:*:table/terraform-lock-*"
              }
            ]
          }
          ```
          
          ## 🚨 Troubleshooting
          
          ### Common Issues
          
          **Access Denied Errors**
          ```bash
          # Check current identity
          aws sts get-caller-identity
          
          # Check assumed role
          aws sts assume-role \
              --role-arn arn:aws:iam::ACCOUNT-ID:role/OrganizationAccountAccessRole \
              --role-session-name test-session
          ```
          
          **GitHub Actions Authentication**
          - Check secret names match exactly
          - Verify secrets are set at repository level
          - Ensure secrets don't contain extra spaces or characters
          
          ### Validation Commands
          
          ```bash
          # Test AWS credentials
          aws sts get-caller-identity
          
          # Test S3 access (for Terraform state)
          aws s3 ls s3://terraform-state-bucket-name
          
          # Test EC2 permissions
          aws ec2 describe-instances --max-items 1
          ```
          
          ## 📋 Setup Checklist
          
          ### For Each Environment:
          
          - [ ] AWS account identified and accessible
          - [ ] IAM user/role created with appropriate permissions
          - [ ] Cross-account roles configured (if using multiple accounts)
          - [ ] S3 bucket for Terraform state (will be created automatically)
          - [ ] DynamoDB table for state locking (will be created automatically)
          - [ ] GitHub secrets configured
          - [ ] Backend configuration updated with correct account IDs
          
          ### Security Checklist:
          
          - [ ] Least privilege permissions applied
          - [ ] Access keys rotated regularly (if using)
          - [ ] CloudTrail enabled for auditing
          - [ ] MFA enabled on AWS accounts
          - [ ] Network access restricted appropriately
          
          ### Testing Checklist:
          
          - [ ] Credentials work locally: `aws sts get-caller-identity`
          - [ ] GitHub Actions can authenticate
          - [ ] Terraform can initialize backend
          - [ ] Terraform can plan/apply in dev environment
          - [ ] Cross-account access works (if applicable)
          
          ---
          
          **Need help with credentials setup? Contact your Platform Engineering team.**
          CREDS_EOF
          
          # Add app-specific information to the setup guide
          cat >> SETUP.md << EOF
          
          ---
          
          ## 🎯 App-Specific Configuration
          
          This repository was created specifically for **${{ needs.validate-inputs.outputs.app_name }}** with the following configuration:
          
          ### AWS Accounts
          - **Development**: ${{ needs.validate-inputs.outputs.dev_account_id }}
          - **Staging**: ${{ needs.validate-inputs.outputs.staging_account_id }}
          - **Production**: ${{ needs.validate-inputs.outputs.prod_account_id }}
          
          ### Approval Workflow
          - **Staging Approvers**: ${{ needs.validate-inputs.outputs.staging_approvers }}
          - **Production Approvers**: ${{ needs.validate-inputs.outputs.prod_approvers }}
          
          ### Primary Region
          - **AWS Region**: ${{ needs.validate-inputs.outputs.aws_region }}
          
          ### Contact Information
          - **App Team**: ${{ github.event.inputs.app_team_contacts || github.event.client_payload.app_team_contacts }}
          - **Platform Team**: platform-engineering@company.com
          
          ### Repository Details
          - **Created**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Platform Pipeline**: ${{ github.repository }}
          - **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          ---
          
          **Next Steps for App Team:**
          1. Clone this repository: \`git clone ${{ needs.create-repository.outputs.clone_url }}\`
          2. Follow the setup instructions above
          3. Configure your tfvars and userdata files
          4. Set up AWS credentials in GitHub secrets
          5. Push to dev branch to start your first deployment
          EOF
          
          echo "✅ Setup instructions created"
          
      - name: Commit and push initial setup
        run: |
          cd target-repo
          
          # Add all files
          git add .
          
          # Create initial commit
          git commit -m "feat: initial infrastructure setup for ${{ needs.validate-inputs.outputs.app_name }}

          - Add Terraform infrastructure orchestration
          - Configure GitOps workflow for dev/staging/production
          - Set up GitHub environments with approvals
          - Add example configurations for tfvars and userdata
          - Configure AWS accounts: dev(${{ needs.validate-inputs.outputs.dev_account_id }}), staging(${{ needs.validate-inputs.outputs.staging_account_id }}), prod(${{ needs.validate-inputs.outputs.prod_account_id }})
          - Include complete platform documentation as PLATFORM-README.md
          
          Created by Platform Engineering Pipeline
          Pipeline Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Next steps:
          1. Configure tfvars files with your specific requirements
          2. Add userdata scripts for server initialization
          3. Set up AWS credentials in GitHub secrets
          4. Push to dev branch to start deployment"
          
          # Push to main branch
          git push origin main
          
          echo "✅ Initial setup committed and pushed"

  setup-gitops-workflow:
    name: Setup GitOps Workflow
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-repository, setup-repository-structure]
    
    steps:
      - name: Checkout base infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: rajamuthuns/terraform-infra-orchestrator-enhanced
          path: base-repo
          
      - name: Setup GitHub CLI and Git
        run: |
          echo "${{ secrets.PLATFORM_GITHUB_TOKEN }}" | gh auth login --with-token
          git config --global credential.helper store
          echo "https://x-access-token:${{ secrets.PLATFORM_GITHUB_TOKEN }}@github.com" > ~/.git-credentials
          git config --global user.name "Platform Engineering Bot"
          git config --global user.email "platform-engineering@company.com"
          
      - name: Create dev branch with all configuration files
        run: |
          # Clone the repository
          gh repo clone "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" target-repo
          cd target-repo
          
          # Create dev branch
          git checkout -b dev
          
          # Copy all infrastructure files to dev branch
          cp ../base-repo/main.tf .
          cp ../base-repo/variables.tf .
          cp ../base-repo/outputs.tf .
          cp ../base-repo/backend.tf .
          cp ../base-repo/Makefile .
          cp ../base-repo/deploy.sh .
          chmod +x deploy.sh
          
          # Copy configuration files
          mkdir -p config
          cp ../base-repo/config/*.json config/
          
          # Update AWS accounts configuration
          cat > config/aws-accounts.json << EOF
          {
            "dev": {
              "account_id": "${{ needs.validate-inputs.outputs.dev_account_id }}",
              "role_name": "OrganizationAccountAccessRole"
            },
            "staging": {
              "account_id": "${{ needs.validate-inputs.outputs.staging_account_id }}",
              "role_name": "OrganizationAccountAccessRole"
            },
            "production": {
              "account_id": "${{ needs.validate-inputs.outputs.prod_account_id }}",
              "role_name": "OrganizationAccountAccessRole"
            }
          }
          EOF
          
          # Copy shared backend configurations
          mkdir -p shared
          cp ../base-repo/shared/*.hcl shared/
          
          # Update backend configurations with account IDs
          sed -i "s/REPLACE_WITH_DEV_ACCOUNT_ID/${{ needs.validate-inputs.outputs.dev_account_id }}/g" shared/backend-dev.hcl
          sed -i "s/REPLACE_WITH_STAGING_ACCOUNT_ID/${{ needs.validate-inputs.outputs.staging_account_id }}/g" shared/backend-staging.hcl
          sed -i "s/REPLACE_WITH_PRODUCTION_ACCOUNT_ID/${{ needs.validate-inputs.outputs.prod_account_id }}/g" shared/backend-prod.hcl
          
          # Copy scripts
          mkdir -p scripts
          cp ../base-repo/scripts/*.sh scripts/
          chmod +x scripts/*.sh
          
          # Copy documentation
          mkdir -p docs
          if [ -d "../base-repo/docs" ]; then
            cp ../base-repo/docs/*.md docs/
          fi
          
          # Copy GitHub workflows (including build and destroy workflows)
          mkdir -p .github/workflows
          if [ -d "../base-repo/.github/workflows" ]; then
            cp ../base-repo/.github/workflows/*.yml .github/workflows/
            echo "✅ Copied GitHub workflows from base repository"
          else
            echo "⚠️ No workflows directory found in base repository"
          fi
          
          # Commit all configuration files to dev branch
          git add .
          git commit -m "feat: add infrastructure configuration files

            - Add Terraform infrastructure files (main.tf, variables.tf, outputs.tf)
            - Add environment-specific tfvars examples
            - Add userdata script examples
            - Add AWS account configurations
            - Add backend configurations for all environments
            - Add deployment scripts and documentation
            - Add GitHub workflows for build and destroy

          Ready for app team configuration and deployment."

          # Push dev branch
          git push -u origin dev
          echo "✅ Created dev branch with all configuration files"
          
      - name: Create empty staging and production branches
        run: |
          cd target-repo
          
          # Create empty staging branch from main (not dev)
          git checkout main
          git checkout -b staging
          git push -u origin staging
          echo "✅ Created empty staging branch (content comes via PR from dev)"
          
          # Create empty production branch from main (not staging)
          git checkout main
          git checkout -b production  
          git push -u origin production
          echo "✅ Created empty production branch (content comes via PR from staging)"

      - name: Setup GitHub environments
        run: |
          REPO_FULL_NAME="${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          
          # Create dev environment (no protection)
          gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/environments/dev" \
            --input - << EOF
          {
            "deployment_branch_policy": {
              "protected_branches": false,
              "custom_branch_policies": true
            }
          }
          EOF
          echo "✅ Created dev environment"
          
          # Create staging environment with reviewers (for both build and destroy)
          echo "Creating staging environment with reviewers: ${{ needs.validate-inputs.outputs.staging_approvers }}"
          STAGING_REVIEWERS='[{"type": "User", "id": null}]'  # Simplified for now
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/environments/staging" \
            --input - << EOF 2>/dev/null
          {
            "deployment_branch_policy": {
              "protected_branches": false,
              "custom_branch_policies": true
            }
          }
          EOF
          then
            echo "✅ Created staging environment"
            echo "   - Manual approval setup required in GitHub UI for: ${{ needs.validate-inputs.outputs.staging_approvers }}"
          else
            echo "❌ Failed to create staging environment"
          fi
          
          # Create production environment with reviewers (for both build and destroy)
          echo "Creating production environment with reviewers: ${{ needs.validate-inputs.outputs.prod_approvers }}"
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/environments/production" \
            --input - << EOF 2>/dev/null
          {
            "deployment_branch_policy": {
              "protected_branches": false,
              "custom_branch_policies": true
            }
          }
          EOF
          then
            echo "✅ Created production environment"
            echo "   - Manual approval setup required in GitHub UI for: ${{ needs.validate-inputs.outputs.prod_approvers }}"
          else
            echo "❌ Failed to create production environment"
          fi
          
      - name: Setup branch protection rules
        run: |
          REPO_FULL_NAME="${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          
          # Try to protect staging branch (requires GitHub Pro for private repos)
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/branches/staging/protection" \
            --input - << 'EOF' 2>/dev/null
          {
            "required_status_checks": null,
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "required_approving_review_count": 1,
              "dismiss_stale_reviews": true,
              "require_code_owner_reviews": false
            },
            "restrictions": null
          }
          EOF
          then
            echo "✅ Protected staging branch"
          else
            echo "⚠️ Branch protection not available - requires GitHub Pro for private repos"
            echo "   Manual setup: Go to Settings → Branches → Add rule for 'staging'"
          fi
          
          # Try to protect production branch (requires GitHub Pro for private repos)
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/branches/production/protection" \
            --input - << 'EOF' 2>/dev/null
          {
            "required_status_checks": null,
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "required_approving_review_count": 2,
              "dismiss_stale_reviews": true,
              "require_code_owner_reviews": false
            },
            "restrictions": null
          }
          EOF
          then
            echo "✅ Protected production branch"
          else
            echo "⚠️ Branch protection not available - requires GitHub Pro for private repos"
            echo "   Manual setup: Go to Settings → Branches → Add rule for 'production'"
          fi

  notify-completion:
    name: Notify App Team
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-repository, setup-repository-structure, setup-gitops-workflow]
    if: always()
    
    steps:
      - name: Create summary
        run: |
          if [[ "${{ needs.setup-gitops-workflow.result }}" == "success" ]]; then
            echo "## ✅ Infrastructure Repository Created Successfully" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Repository:** [${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Branch Structure:**" >> $GITHUB_STEP_SUMMARY
            echo "- 🏠 **Main**: README and workflows only" >> $GITHUB_STEP_SUMMARY
            echo "- 🔧 **Dev**: All configuration files and examples (auto-deploy)" >> $GITHUB_STEP_SUMMARY
            echo "- 🧪 **Staging**: Ready for staging deployments (requires approval)" >> $GITHUB_STEP_SUMMARY
            echo "- 🚀 **Production**: Ready for production deployments (requires approval)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment Setup:**" >> $GITHUB_STEP_SUMMARY
            echo "- 🔧 **Dev**: Ready for auto-deployment" >> $GITHUB_STEP_SUMMARY
            echo "- 🧪 **Staging**: Environment created - add reviewers manually: ${{ needs.validate-inputs.outputs.staging_approvers }}" >> $GITHUB_STEP_SUMMARY
            echo "- 🚀 **Production**: Environment created - add reviewers manually: ${{ needs.validate-inputs.outputs.prod_approvers }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Manual Setup Required:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Go to repository Settings → Environments" >> $GITHUB_STEP_SUMMARY
            echo "2. Configure reviewers for staging and production environments" >> $GITHUB_STEP_SUMMARY
            echo "3. Enable 'Prevent self-review' if desired" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps for App Team:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Clone repository: \`git clone https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Switch to dev branch: \`git checkout dev\`" >> $GITHUB_STEP_SUMMARY
            echo "3. Configure tfvars and userdata files" >> $GITHUB_STEP_SUMMARY
            echo "4. Set up AWS credentials in GitHub secrets" >> $GITHUB_STEP_SUMMARY
            echo "5. Push to dev branch to start deployment" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ❌ Infrastructure Repository Creation Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Send email notification to app team
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER || 'smtp.gmail.com' }}
          server_port: ${{ secrets.SMTP_PORT || '587' }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: |
            ${{ needs.setup-gitops-workflow.result == 'success' && '✅' || '❌' }} Infrastructure Repository: ${{ needs.validate-inputs.outputs.app_name }}
          to: ${{ github.event.inputs.app_team_contacts || github.event.client_payload.app_team_contacts }}
          from: Platform Engineering <${{ secrets.SMTP_USERNAME }}>
          html_body: |
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .header { background-color: ${{ needs.setup-gitops-workflow.result == 'success' && '#d4edda' || '#f8d7da' }}; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
                    .success { color: #155724; }
                    .error { color: #721c24; }
                    .info-box { background-color: #f8f9fa; padding: 15px; border-left: 4px solid #007bff; margin: 10px 0; }
                    .code { background-color: #f1f1f1; padding: 10px; border-radius: 3px; font-family: monospace; }
                    ul { padding-left: 20px; }
                    .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 0.9em; color: #666; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2 class="${{ needs.setup-gitops-workflow.result == 'success' && 'success' || 'error' }}">
                        ${{ needs.setup-gitops-workflow.result == 'success' && '✅ Infrastructure Repository Created Successfully' || '❌ Infrastructure Repository Creation Failed' }}
                    </h2>
                </div>

                ${{ needs.setup-gitops-workflow.result == 'success' && format('
                <div class="info-box">
                    <h3>📋 Repository Details</h3>
                    <ul>
                        <li><strong>Repository:</strong> <a href="https://github.com/{0}/{1}">{0}/{1}</a></li>
                        <li><strong>App Name:</strong> {2}</li>
                        <li><strong>Created by:</strong> {3}</li>
                        <li><strong>Creation Date:</strong> {4}</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>🏗️ Branch Structure</h3>
                    <ul>
                        <li>🏠 <strong>Main:</strong> README and workflows only</li>
                        <li>🔧 <strong>Dev:</strong> All configuration files and examples (auto-deploy)</li>
                        <li>🧪 <strong>Staging:</strong> Ready for staging deployments (requires approval)</li>
                        <li>🚀 <strong>Production:</strong> Ready for production deployments (requires approval)</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>⚙️ Environment Setup</h3>
                    <ul>
                        <li>🔧 <strong>Dev:</strong> Ready for auto-deployment</li>
                        <li>🧪 <strong>Staging:</strong> Environment created - add reviewers manually: {5}</li>
                        <li>🚀 <strong>Production:</strong> Environment created - add reviewers manually: {6}</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>🔧 Manual Setup Required</h3>
                    <ol>
                        <li>Go to repository Settings → Environments</li>
                        <li>Configure reviewers for staging and production environments</li>
                        <li>Enable ''Prevent self-review'' if desired</li>
                    </ol>
                </div>

                <div class="info-box">
                    <h3>🚀 Next Steps for App Team</h3>
                    <ol>
                        <li>Clone repository:
                            <div class="code">git clone https://github.com/{0}/{1}.git</div>
                        </li>
                        <li>Switch to dev branch:
                            <div class="code">git checkout dev</div>
                        </li>
                        <li>Configure tfvars and userdata files</li>
                        <li>Set up AWS credentials in GitHub secrets</li>
                        <li>Push to dev branch to start deployment</li>
                    </ol>
                </div>

                <div class="info-box">
                    <h3>📖 Documentation</h3>
                    <ul>
                        <li><a href="https://github.com/{0}/{1}/blob/main/README.md">README.md</a> - Project overview</li>
                        <li><a href="https://github.com/{0}/{1}/blob/main/SETUP.md">SETUP.md</a> - Detailed setup instructions</li>
                        <li><a href="https://github.com/{0}/{1}/blob/dev/tfvars/README.md">tfvars/README.md</a> - Configuration guide</li>
                        <li><a href="https://github.com/{0}/{1}/blob/dev/userdata/README.md">userdata/README.md</a> - Script guide</li>
                    </ul>
                </div>
                ', needs.validate-inputs.outputs.target_org, needs.validate-inputs.outputs.repo_name, needs.validate-inputs.outputs.app_name, github.actor, github.event.head_commit.timestamp, needs.validate-inputs.outputs.staging_approvers, needs.validate-inputs.outputs.prod_approvers) || format('
                <div class="info-box">
                    <h3>❌ Repository Creation Failed</h3>
                    <p>There was an issue creating your infrastructure repository. Please check the workflow logs for details:</p>
                    <p><a href="{0}/{1}/actions/runs/{2}">View Workflow Logs</a></p>
                    <p>If you need assistance, please contact the Platform Engineering team.</p>
                </div>
                ', github.server_url, github.repository, github.run_id) }}

                <div class="footer">
                    <p><strong>Platform Engineering Team</strong><br>
                    This is an automated notification from the Infrastructure Platform.<br>
                    Workflow Run: <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Details</a></p>
                </div>
            </body>
            </html>