name: Create App Team Infrastructure Repository

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Application name (e.g., my-web-app)'
        required: true
        type: string
      
      target_github_org:
        description: 'Target GitHub organization for app team'
        required: true
        type: string
      
      app_team_contacts:
        description: 'App team contact emails (comma-separated)'
        required: true
        type: string
      
      aws_accounts:
        description: 'AWS Account IDs (format: dev:123456789012,staging:123456789013,prod:123456789014)'
        required: true
        type: string
      
      staging_approvers:
        description: 'GitHub usernames for staging approvals (comma-separated)'
        required: true
        type: string
      
      prod_approvers:
        description: 'GitHub usernames for production approvals (comma-separated)'
        required: true
        type: string
      
      aws_region:
        description: 'Primary AWS region'
        required: false
        type: choice
        default: 'us-east-1'
        options:
          - 'us-east-1'
          - 'us-west-2'
          - 'eu-west-1'
          - 'ap-southeast-1'

  # API trigger support
  repository_dispatch:
    types: [create-app-infrastructure]

env:
  REPO_NAME: "${{ github.event.inputs.app_name || github.event.client_payload.app_name }}-infrastructure"
  TARGET_ORG: "${{ github.event.inputs.target_github_org || github.event.client_payload.target_github_org }}"
  APP_NAME: "${{ github.event.inputs.app_name || github.event.client_payload.app_name }}"

jobs:
  validate-inputs:
    name: Validate Inputs
    runs-on: ubuntu-latest
    outputs:
      app_name: ${{ steps.validate.outputs.app_name }}
      repo_name: ${{ steps.validate.outputs.repo_name }}
      target_org: ${{ steps.validate.outputs.target_org }}
      dev_account_id: ${{ steps.validate.outputs.dev_account_id }}
      staging_account_id: ${{ steps.validate.outputs.staging_account_id }}
      prod_account_id: ${{ steps.validate.outputs.prod_account_id }}
      staging_approvers: ${{ steps.validate.outputs.staging_approvers }}
      prod_approvers: ${{ steps.validate.outputs.prod_approvers }}
      aws_region: ${{ steps.validate.outputs.aws_region }}
      
    steps:
      - name: Validate and normalize inputs
        id: validate
        run: |
          # Get inputs from either workflow_dispatch or repository_dispatch
          APP_NAME="${{ github.event.inputs.app_name || github.event.client_payload.app_name }}"
          TARGET_ORG="${{ github.event.inputs.target_github_org || github.event.client_payload.target_github_org }}"
          AWS_ACCOUNTS="${{ github.event.inputs.aws_accounts || github.event.client_payload.aws_accounts }}"
          STAGING_APPROVERS="${{ github.event.inputs.staging_approvers || github.event.client_payload.staging_approvers }}"
          PROD_APPROVERS="${{ github.event.inputs.prod_approvers || github.event.client_payload.prod_approvers }}"
          AWS_REGION="${{ github.event.inputs.aws_region || github.event.client_payload.aws_region || 'us-east-1' }}"
          
          # Debug: Show raw inputs
          echo "ðŸ” Debug - Raw inputs:"
          echo "AWS_ACCOUNTS: '$AWS_ACCOUNTS'"
          echo "STAGING_APPROVERS: '$STAGING_APPROVERS'"
          echo "PROD_APPROVERS: '$PROD_APPROVERS'"
          
          # Parse AWS accounts (format: dev:123456789012,staging:123456789013,prod:123456789014)
          DEV_ACCOUNT=$(echo "$AWS_ACCOUNTS" | grep -oE 'dev:[0-9]{12}' | cut -d: -f2)
          STAGING_ACCOUNT=$(echo "$AWS_ACCOUNTS" | grep -oE 'staging:[0-9]{12}' | cut -d: -f2)
          PROD_ACCOUNT=$(echo "$AWS_ACCOUNTS" | grep -oE 'prod:[0-9]{12}' | cut -d: -f2)
          
          # Debug: Show parsed values
          echo "ðŸ” Debug - Parsed values:"
          echo "DEV_ACCOUNT: '$DEV_ACCOUNT'"
          echo "STAGING_ACCOUNT: '$STAGING_ACCOUNT'"
          echo "PROD_ACCOUNT: '$PROD_ACCOUNT'"
          echo "STAGING_APPROVERS: '$STAGING_APPROVERS'"
          echo "PROD_APPROVERS: '$PROD_APPROVERS'"
          
          # Validate app name format
          if [[ ! "$APP_NAME" =~ ^[a-z0-9-]+$ ]]; then
            echo "âŒ App name must contain only lowercase letters, numbers, and hyphens"
            exit 1
          fi
          
          # Validate AWS account IDs
          for account in "$DEV_ACCOUNT" "$STAGING_ACCOUNT" "$PROD_ACCOUNT"; do
            if [[ ! "$account" =~ ^[0-9]{12}$ ]]; then
              echo "âŒ Invalid AWS account ID format: $account (must be 12 digits)"
              exit 1
            fi
          done
          
          # Generate repository name
          REPO_NAME="${APP_NAME}-infrastructure"
          
          # Set outputs
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "target_org=$TARGET_ORG" >> $GITHUB_OUTPUT
          echo "dev_account_id=$DEV_ACCOUNT" >> $GITHUB_OUTPUT
          echo "staging_account_id=$STAGING_ACCOUNT" >> $GITHUB_OUTPUT
          echo "prod_account_id=$PROD_ACCOUNT" >> $GITHUB_OUTPUT
          echo "staging_approvers=$STAGING_APPROVERS" >> $GITHUB_OUTPUT
          echo "prod_approvers=$PROD_APPROVERS" >> $GITHUB_OUTPUT
          echo "aws_region=$AWS_REGION" >> $GITHUB_OUTPUT
          
          echo "âœ… Input validation completed"
          echo "ðŸ“‹ App Name: $APP_NAME"
          echo "ðŸ“‹ Repository: $TARGET_ORG/$REPO_NAME"
          echo "ðŸ“‹ AWS Accounts: Dev($DEV_ACCOUNT), Staging($STAGING_ACCOUNT), Prod($PROD_ACCOUNT)"

  create-repository:
    name: Create GitHub Repository
    runs-on: ubuntu-latest
    needs: validate-inputs
    outputs:
      repository_url: ${{ steps.create-repo.outputs.repository_url }}
      clone_url: ${{ steps.create-repo.outputs.clone_url }}
      
    steps:
      - name: Checkout platform repository
        uses: actions/checkout@v4
        
      - name: Setup GitHub CLI
        run: |
          gh --version
          echo "${{ secrets.PLATFORM_GITHUB_TOKEN }}" | gh auth login --with-token
          
      - name: Check if repository exists
        id: check-repo
        run: |
          if gh repo view "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ Repository already exists: ${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âœ… Repository name is available"
          fi
          
      - name: Create GitHub repository
        id: create-repo
        if: steps.check-repo.outputs.exists == 'false'
        run: |
          # Create repository
          gh repo create "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" \
            --description "Infrastructure as Code for ${{ needs.validate-inputs.outputs.app_name }}" \
            --private \
            --clone=false
          
          # Set outputs
          REPO_URL="https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          CLONE_URL="git@github.com:${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git"
          
          echo "repository_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "clone_url=$CLONE_URL" >> $GITHUB_OUTPUT
          
          echo "âœ… Repository created: $REPO_URL"
          
      - name: Handle existing repository
        if: steps.check-repo.outputs.exists == 'true'
        run: |
          echo "âš ï¸ Repository already exists. Skipping creation."
          echo "ðŸ“‹ Existing repository: https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          
          # Set outputs for existing repo
          REPO_URL="https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          CLONE_URL="git@github.com:${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git"
          
          echo "repository_url=$REPO_URL" >> $GITHUB_OUTPUT
          echo "clone_url=$CLONE_URL" >> $GITHUB_OUTPUT

  setup-repository-structure:
    name: Setup Repository Structure
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-repository]
    
    steps:
      - name: Checkout base infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: rajamuthuns/terraform-infra-orchestrator-enhanced
          path: base-repo
        

          
      - name: Clone target repository
        run: |
          echo "${{ secrets.PLATFORM_GITHUB_TOKEN }}" | gh auth login --with-token
          gh repo clone "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" target-repo
          cd target-repo
          
          # Configure Git to use the token for authentication
          git config --global credential.helper store
          echo "https://x-access-token:${{ secrets.PLATFORM_GITHUB_TOKEN }}@github.com" > ~/.git-credentials
          git config --global user.name "Platform Engineering Bot"
          git config --global user.email "platform-engineering@company.com"
          
      - name: Setup main branch (minimal)
        run: |
          cd target-repo
          
          # Copy only essential files to main branch
          cp ../base-repo/.gitignore .
          
          # Copy GitHub workflows
          mkdir -p .github/workflows
          cp -r ../base-repo/.github/workflows/* .github/workflows/
          
          echo "âœ… Main branch setup completed (minimal files only)"
          

          

          
      - name: Copy main workspace README and create app-specific README
        run: |
          cd target-repo
          
          # Copy the main workspace README.md as PLATFORM-README.md for reference
          cp ../base-repo/README.md PLATFORM-README.md
          
          # Create app-specific README
          cat > README.md << EOF
          # ${{ needs.validate-inputs.outputs.app_name }} Infrastructure
          
          Infrastructure as Code for ${{ needs.validate-inputs.outputs.app_name }} using Terraform and GitOps workflow.
          
          ## ðŸ—ï¸ Architecture
          
          This repository uses the Terraform Infrastructure Orchestrator pattern to manage infrastructure across multiple environments (dev, staging, production) with GitOps workflow.
          
          ### Environments
          - **Development**: Account ID ${{ needs.validate-inputs.outputs.dev_account_id }}
          - **Staging**: Account ID ${{ needs.validate-inputs.outputs.staging_account_id }}  
          - **Production**: Account ID ${{ needs.validate-inputs.outputs.prod_account_id }}
          
          ### Approvers
          - **Staging**: ${{ needs.validate-inputs.outputs.staging_approvers }}
          - **Production**: ${{ needs.validate-inputs.outputs.prod_approvers }}
          
          ## ðŸš€ Quick Start
          
          ### 1. Configure Your Infrastructure
          
          Create your environment-specific configuration files:
          
          \`\`\`bash
          # Copy example files and customize
          cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars
          cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars
          cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars
          
          # Edit each file with your specific requirements
          nano tfvars/dev-terraform.tfvars
          nano tfvars/stg-terraform.tfvars
          nano tfvars/prod-terraform.tfvars
          \`\`\`
          
          ### 2. Add User Data Scripts
          
          Create your server initialization scripts:
          
          \`\`\`bash
          # Copy example files and customize
          cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh
          # cp userdata/userdata-windows.ps1.example userdata/userdata-windows.ps1  # If needed
          
          # Edit scripts for your application
          nano userdata/userdata-linux.sh
          \`\`\`
          
          ### 3. Set Up AWS Credentials
          
          Configure GitHub repository secrets (see SETUP.md for details):
          - AWS_ACCESS_KEY_ID
          - AWS_SECRET_ACCESS_KEY
          - PRIVATE_REPO_TOKEN (for private modules)
          
          ### 4. Deploy with GitOps
          
          \`\`\`bash
          # Add all your configurations
          git add .
          git commit -m "feat: initial infrastructure configuration"
          git push origin dev
          
          # GitOps workflow will automatically:
          # 1. Deploy to dev environment
          # 2. Create PR to staging (requires approval)
          # 3. Create PR to production (requires approval)
          \`\`\`
          
          ## ðŸŒ Environments and Approvals
          
          - **Dev**: Auto-deploys on push to dev branch
          - **Staging**: Requires approval from: ${{ needs.validate-inputs.outputs.staging_approvers }}
          - **Production**: Requires approval from: ${{ needs.validate-inputs.outputs.prod_approvers }}
          
          ## ðŸ“ Project Structure
          
          \`\`\`
          ${{ needs.validate-inputs.outputs.repo_name }}/
          â”œâ”€â”€ README.md                          # This file
          â”œâ”€â”€ PLATFORM-README.md                 # Complete platform documentation
          â”œâ”€â”€ SETUP.md                           # Detailed setup instructions
          â”œâ”€â”€ main.tf                            # Infrastructure orchestration
          â”œâ”€â”€ variables.tf                       # Variable definitions
          â”œâ”€â”€ outputs.tf                         # Output definitions
          â”œâ”€â”€ backend.tf                         # Backend configuration
          â”œâ”€â”€ tfvars/                            # Environment configurations
          â”‚   â”œâ”€â”€ dev-terraform.tfvars           # Development config
          â”‚   â”œâ”€â”€ stg-terraform.tfvars           # Staging config
          â”‚   â””â”€â”€ prod-terraform.tfvars          # Production config
          â”œâ”€â”€ userdata/                          # Server initialization scripts
          â”‚   â”œâ”€â”€ userdata-linux.sh              # Linux initialization
          â”‚   â””â”€â”€ userdata-windows.ps1           # Windows initialization
          â”œâ”€â”€ .github/workflows/                 # GitOps CI/CD pipelines
          â”œâ”€â”€ config/                            # Environment configurations
          â”œâ”€â”€ shared/                            # Backend configurations
          â”œâ”€â”€ scripts/                           # Utility scripts
          â””â”€â”€ docs/                              # Documentation
          \`\`\`
          
          ## ðŸ› ï¸ Local Development
          
          \`\`\`bash
          # Plan changes for development
          ./deploy.sh dev plan
          
          # Apply changes to development
          ./deploy.sh dev apply
          
          # Plan changes for staging
          ./deploy.sh staging plan
          \`\`\`
          
          ## ðŸ“– Documentation
          
          - [SETUP.md](SETUP.md) - Detailed setup instructions
          - [CREDENTIALS-SETUP.md](CREDENTIALS-SETUP.md) - AWS credentials setup guide
          - [PLATFORM-README.md](PLATFORM-README.md) - Complete platform documentation
          - [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) - Architecture details
          - [docs/TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md) - Common issues
          
          ## ðŸ†˜ Support
          
          For questions or issues:
          1. Check the SETUP.md file
          2. Review PLATFORM-README.md for complete documentation
          3. Review documentation in docs/ folder
          4. Contact the Platform Engineering team
          5. Create an issue in this repository
          
          ---
          
          **Repository created by Platform Engineering Pipeline**  
          **Creation Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")  
          **Platform Team**: Contact platform-engineering@company.com for support
          EOF
          
          echo "âœ… App-specific README created and main workspace README copied"
          
      - name: Create comprehensive setup instructions
        run: |
          cd target-repo
          
          # Create comprehensive setup guide (embedded in workflow since platform repo is separate)
          cat > SETUP.md << 'SETUP_EOF'
          # Setup Instructions for App Team
          
          This guide will help you complete the setup of your infrastructure repository.
          
          ## ðŸŽ¯ Overview
          
          Your infrastructure repository has been created with the following structure:
          - âœ… Base Terraform files copied
          - âœ… GitOps workflow configured
          - âœ… GitHub environments set up
          - âš ï¸ **Action Required**: Configure tfvars and userdata
          - âš ï¸ **Action Required**: Set up AWS credentials
          
          ## ðŸ“‹ Required Actions
          
          ### 1. Configure Infrastructure (tfvars)
          
          Create your environment-specific configuration files:
          
          ```bash
          # Copy example files
          cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars
          cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars
          cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars
          ```
          
          **Key configurations to update:**
          
          #### In all tfvars files:
          - `gitlab_org` - Your GitLab organization name
          - `base_modules` - Module repositories and versions
          - VPC names (must match your existing VPCs)
          - Subnet names (must match your existing subnets)
          - Key pair names (must exist in your AWS accounts)
          
          #### Environment-specific values:
          - `instance_type` - Different sizes per environment
          - `root_volume_size` - Storage requirements
          - `ami_name` - AMI selection criteria
          - SSL certificates for production ALB
          
          ### 2. Create User Data Scripts
          
          Create server initialization scripts:
          
          ```bash
          # Copy example files
          cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh
          # cp userdata/userdata-windows.ps1.example userdata/userdata-windows.ps1  # If needed
          ```
          
          **Customize the scripts for your application:**
          - Install required software packages
          - Configure application settings
          - Set up monitoring and logging
          - Configure environment-specific settings
          
          ### 3. Set Up AWS Credentials
          
          Configure the following GitHub repository secrets:
          
          #### Go to: Repository Settings â†’ Secrets and variables â†’ Actions
          
          **Required Secrets:**
          ```
          AWS_ACCESS_KEY_ID          - AWS access key for deployments
          AWS_SECRET_ACCESS_KEY      - AWS secret key for deployments
          PRIVATE_REPO_TOKEN         - GitHub token for private module access
          ```
          
          **Optional Secrets:**
          ```
          GITLAB_TOKEN              - GitLab token if using GitLab modules
          SLACK_WEBHOOK_URL         - For deployment notifications
          ```
          
          ### 4. Test Your Setup
          
          **Step 1: Validate Configuration**
          ```bash
          # Check Terraform syntax
          terraform fmt -check
          terraform validate
          ```
          
          **Step 2: Test Development Deployment**
          ```bash
          # Switch to dev branch
          git checkout dev
          
          # Add your configurations
          git add tfvars/ userdata/
          git commit -m "feat: add initial infrastructure configuration"
          git push origin dev
          
          # Monitor GitHub Actions for deployment
          ```
          
          **Step 3: Verify Infrastructure**
          - Check AWS console for created resources
          - Verify EC2 instances are running
          - Test ALB endpoints
          - Check user data script execution logs
          
          ## ðŸš€ Deployment Workflow
          
          ### GitOps Workflow
          1. **Development**: Push to `dev` branch â†’ Auto-deploy to dev environment
          2. **Staging**: Merge dev to `staging` â†’ Requires team approval â†’ Deploy to staging
          3. **Production**: Merge staging to `production` â†’ Requires senior approval â†’ Deploy to production
          
          ### Manual Deployment
          ```bash
          # Local development testing
          ./deploy.sh dev plan
          ./deploy.sh dev apply
          
          # Staging deployment
          ./deploy.sh staging plan
          ./deploy.sh staging apply
          
          # Production deployment (with confirmation)
          ./deploy.sh production plan
          ./deploy.sh production apply
          ```
          
          ## ðŸ›¡ï¸ Security Best Practices
          
          ### Secrets Management
          - Never commit secrets to repository
          - Use AWS Systems Manager Parameter Store
          - Use AWS Secrets Manager for database passwords
          - Rotate credentials regularly
          
          ### Access Control
          - Use least privilege IAM policies
          - Enable MFA for AWS accounts
          - Restrict GitHub repository access
          - Use branch protection rules
          
          ## ðŸ” Troubleshooting
          
          ### Common Issues
          
          **Terraform Backend Errors:**
          ```bash
          # Initialize backend
          terraform init -backend-config=shared/backend-dev.hcl
          
          # If backend doesn't exist, run setup
          ./scripts/setup-backend-per-account.sh
          ```
          
          **Module Download Failures:**
          - Check PRIVATE_REPO_TOKEN has access to module repositories
          - Verify module repository URLs in main.tf
          - Ensure module versions/tags exist
          
          **AWS Permission Errors:**
          - Verify AWS credentials in GitHub secrets
          - Check IAM policies have required permissions
          - Ensure cross-account roles are configured correctly
          
          **VPC/Subnet Not Found:**
          - Verify VPC and subnet names in tfvars files
          - Check that resources exist in target AWS accounts
          - Ensure Name tags match exactly
          
          ### Getting Help
          
          1. **Check Logs:**
             - GitHub Actions workflow logs
             - CloudWatch logs for EC2 instances
             - Terraform plan/apply output
          
          2. **Validate Configuration:**
             ```bash
             terraform fmt -check
             terraform validate
             terraform plan -var-file=tfvars/dev-terraform.tfvars
             ```
          
          3. **Contact Support:**
             - Create issue in this repository
             - Contact Platform Engineering team
             - Check PLATFORM-README.md for complete documentation
          
          ## ðŸ“š Additional Resources
          
          - [Terraform Documentation](https://www.terraform.io/docs)
          - [AWS Provider Documentation](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)
          - [GitHub Actions Documentation](https://docs.github.com/en/actions)
          - [GitOps Best Practices](https://www.gitops.tech/)
          
          ---
          
          **Next Steps:**
          1. Complete the required actions above
          2. Test your development environment
          3. Set up monitoring and alerting
          4. Document your application-specific configurations
          5. Train your team on the GitOps workflow
          SETUP_EOF
          
          # Create credentials setup guide
          cat > CREDENTIALS-SETUP.md << 'CREDS_EOF'
          # AWS Credentials Setup Guide
          
          This guide explains how to set up AWS credentials for your infrastructure deployment pipeline.
          
          ## ðŸŽ¯ Overview
          
          Your infrastructure needs AWS credentials to deploy resources across different environments. This guide covers multiple approaches from simple to enterprise-grade security.
          
          ## ðŸ” Authentication Methods
          
          ### Method 1: IAM User with Access Keys (Simple)
          
          **Best for**: Small teams, development environments, getting started quickly
          
          #### Step 1: Create IAM User
          ```bash
          # Using AWS CLI (if you have admin access)
          aws iam create-user --user-name terraform-deployer
          
          # Attach PowerUser policy (or create custom policy)
          aws iam attach-user-policy \
              --user-name terraform-deployer \
              --policy-arn arn:aws:iam::aws:policy/PowerUserAccess
          ```
          
          #### Step 2: Create Access Keys
          ```bash
          # Create access key
          aws iam create-access-key --user-name terraform-deployer
          
          # Output will show:
          # AccessKeyId: AKIA...
          # SecretAccessKey: ...
          ```
          
          #### Step 3: Add to GitHub Secrets
          1. Go to your repository: `Settings` â†’ `Secrets and variables` â†’ `Actions`
          2. Add these secrets:
             - `AWS_ACCESS_KEY_ID`: Your access key ID
             - `AWS_SECRET_ACCESS_KEY`: Your secret access key
          
          ### Method 2: Cross-Account Roles (Recommended)
          
          **Best for**: Production environments, enterprise security, multiple AWS accounts
          
          Your backend configurations already reference OrganizationAccountAccessRole:
          
          ```hcl
          # shared/backend-dev.hcl
          role_arn = "arn:aws:iam::DEV-ACCOUNT-ID:role/OrganizationAccountAccessRole"
          
          # shared/backend-staging.hcl  
          role_arn = "arn:aws:iam::STAGING-ACCOUNT-ID:role/OrganizationAccountAccessRole"
          
          # shared/backend-prod.hcl
          role_arn = "arn:aws:iam::PROD-ACCOUNT-ID:role/OrganizationAccountAccessRole"
          ```
          
          ## ðŸ”‘ Required Permissions
          
          ### Minimum IAM Policy for Terraform
          
          ```json
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:*",
                  "elasticloadbalancing:*",
                  "autoscaling:*",
                  "cloudwatch:*",
                  "logs:*",
                  "iam:ListInstanceProfiles",
                  "iam:PassRole",
                  "s3:GetObject",
                  "s3:PutObject",
                  "s3:DeleteObject",
                  "s3:ListBucket",
                  "dynamodb:GetItem",
                  "dynamodb:PutItem",
                  "dynamodb:DeleteItem",
                  "dynamodb:DescribeTable"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "s3:CreateBucket",
                  "s3:DeleteBucket",
                  "s3:GetBucketVersioning",
                  "s3:PutBucketVersioning",
                  "s3:GetBucketEncryption",
                  "s3:PutBucketEncryption",
                  "s3:PutBucketPublicAccessBlock"
                ],
                "Resource": "arn:aws:s3:::terraform-state-*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "dynamodb:CreateTable",
                  "dynamodb:DeleteTable",
                  "dynamodb:DescribeTable"
                ],
                "Resource": "arn:aws:dynamodb:*:*:table/terraform-lock-*"
              }
            ]
          }
          ```
          
          ## ðŸš¨ Troubleshooting
          
          ### Common Issues
          
          **Access Denied Errors**
          ```bash
          # Check current identity
          aws sts get-caller-identity
          
          # Check assumed role
          aws sts assume-role \
              --role-arn arn:aws:iam::ACCOUNT-ID:role/OrganizationAccountAccessRole \
              --role-session-name test-session
          ```
          
          **GitHub Actions Authentication**
          - Check secret names match exactly
          - Verify secrets are set at repository level
          - Ensure secrets don't contain extra spaces or characters
          
          ### Validation Commands
          
          ```bash
          # Test AWS credentials
          aws sts get-caller-identity
          
          # Test S3 access (for Terraform state)
          aws s3 ls s3://terraform-state-bucket-name
          
          # Test EC2 permissions
          aws ec2 describe-instances --max-items 1
          ```
          
          ## ðŸ“‹ Setup Checklist
          
          ### For Each Environment:
          
          - [ ] AWS account identified and accessible
          - [ ] IAM user/role created with appropriate permissions
          - [ ] Cross-account roles configured (if using multiple accounts)
          - [ ] S3 bucket for Terraform state (will be created automatically)
          - [ ] DynamoDB table for state locking (will be created automatically)
          - [ ] GitHub secrets configured
          - [ ] Backend configuration updated with correct account IDs
          
          ### Security Checklist:
          
          - [ ] Least privilege permissions applied
          - [ ] Access keys rotated regularly (if using)
          - [ ] CloudTrail enabled for auditing
          - [ ] MFA enabled on AWS accounts
          - [ ] Network access restricted appropriately
          
          ### Testing Checklist:
          
          - [ ] Credentials work locally: `aws sts get-caller-identity`
          - [ ] GitHub Actions can authenticate
          - [ ] Terraform can initialize backend
          - [ ] Terraform can plan/apply in dev environment
          - [ ] Cross-account access works (if applicable)
          
          ---
          
          **Need help with credentials setup? Contact your Platform Engineering team.**
          CREDS_EOF
          
          # Add app-specific information to the setup guide
          cat >> SETUP.md << EOF
          
          ---
          
          ## ðŸŽ¯ App-Specific Configuration
          
          This repository was created specifically for **${{ needs.validate-inputs.outputs.app_name }}** with the following configuration:
          
          ### AWS Accounts
          - **Development**: ${{ needs.validate-inputs.outputs.dev_account_id }}
          - **Staging**: ${{ needs.validate-inputs.outputs.staging_account_id }}
          - **Production**: ${{ needs.validate-inputs.outputs.prod_account_id }}
          
          ### Approval Workflow
          - **Staging Approvers**: ${{ needs.validate-inputs.outputs.staging_approvers }}
          - **Production Approvers**: ${{ needs.validate-inputs.outputs.prod_approvers }}
          
          ### Primary Region
          - **AWS Region**: ${{ needs.validate-inputs.outputs.aws_region }}
          
          ### Contact Information
          - **App Team**: ${{ github.event.inputs.app_team_contacts || github.event.client_payload.app_team_contacts }}
          - **Platform Team**: platform-engineering@company.com
          
          ### Repository Details
          - **Created**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Platform Pipeline**: ${{ github.repository }}
          - **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          ---
          
          **Next Steps for App Team:**
          1. Clone this repository: \`git clone ${{ needs.create-repository.outputs.clone_url }}\`
          2. Follow the setup instructions above
          3. Configure your tfvars and userdata files
          4. Set up AWS credentials in GitHub secrets
          5. Push to dev branch to start your first deployment
          EOF
          
          echo "âœ… Setup instructions created"
          
      - name: Commit and push initial setup
        run: |
          cd target-repo
          
          # Add all files
          git add .
          
          # Create initial commit
          git commit -m "feat: initial infrastructure setup for ${{ needs.validate-inputs.outputs.app_name }}

          - Add Terraform infrastructure orchestration
          - Configure GitOps workflow for dev/staging/production
          - Set up GitHub environments with approvals
          - Add example configurations for tfvars and userdata
          - Configure AWS accounts: dev(${{ needs.validate-inputs.outputs.dev_account_id }}), staging(${{ needs.validate-inputs.outputs.staging_account_id }}), prod(${{ needs.validate-inputs.outputs.prod_account_id }})
          - Include complete platform documentation as PLATFORM-README.md
          
          Created by Platform Engineering Pipeline
          Pipeline Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Next steps:
          1. Configure tfvars files with your specific requirements
          2. Add userdata scripts for server initialization
          3. Set up AWS credentials in GitHub secrets
          4. Push to dev branch to start deployment"
          
          # Push to main branch
          git push origin main
          
          echo "âœ… Initial setup committed and pushed"

  setup-gitops-workflow:
    name: Setup GitOps Workflow
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-repository, setup-repository-structure]
    
    steps:
      - name: Checkout base infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: rajamuthuns/terraform-infra-orchestrator-enhanced
          path: base-repo
          
      - name: Setup GitHub CLI and Git
        run: |
          echo "${{ secrets.PLATFORM_GITHUB_TOKEN }}" | gh auth login --with-token
          git config --global credential.helper store
          echo "https://x-access-token:${{ secrets.PLATFORM_GITHUB_TOKEN }}@github.com" > ~/.git-credentials
          git config --global user.name "Platform Engineering Bot"
          git config --global user.email "platform-engineering@company.com"
          
      - name: Create dev branch with all configuration files
        run: |
          # Clone the repository
          gh repo clone "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" target-repo
          cd target-repo
          
          # Create dev branch
          git checkout -b dev
          
          # Copy core infrastructure files (if they exist)
          echo "ðŸ“‹ Copying infrastructure files from base repository..."
          
          # Copy Terraform files
          [ -f "../base-repo/main.tf" ] && cp ../base-repo/main.tf . || echo "âš ï¸ main.tf not found"
          [ -f "../base-repo/variables.tf" ] && cp ../base-repo/variables.tf . || echo "âš ï¸ variables.tf not found"
          [ -f "../base-repo/outputs.tf" ] && cp ../base-repo/outputs.tf . || echo "âš ï¸ outputs.tf not found"
          [ -f "../base-repo/backend.tf" ] && cp ../base-repo/backend.tf . || echo "âš ï¸ backend.tf not found"
          
          # Copy build files
          [ -f "../base-repo/Makefile" ] && cp ../base-repo/Makefile . || echo "âš ï¸ Makefile not found"
          [ -f "../base-repo/deploy.sh" ] && cp ../base-repo/deploy.sh . && chmod +x deploy.sh || echo "âš ï¸ deploy.sh not found"
          
          # Copy gitignore
          [ -f "../base-repo/.gitignore" ] && cp ../base-repo/.gitignore . || echo "âš ï¸ .gitignore not found"
          
          echo "âœ… Infrastructure files copied (available files only)"
          
          # Copy configuration files (if they exist)
          if [ -d "../base-repo/config" ]; then
            mkdir -p config
            # Copy all files from config directory
            cp -r ../base-repo/config/* config/ 2>/dev/null || echo "âš ï¸ No files found in config directory"
            echo "âœ… Copied all configuration files from base repository"
          else
            mkdir -p config
            echo "âš ï¸ No config directory found in base repository - creating empty config directory"
          fi
          
          # Update AWS accounts configuration
          cat > config/aws-accounts.json << EOF
          {
            "dev": {
              "account_id": "${{ needs.validate-inputs.outputs.dev_account_id }}",
              "role_name": "OrganizationAccountAccessRole"
            },
            "staging": {
              "account_id": "${{ needs.validate-inputs.outputs.staging_account_id }}",
              "role_name": "OrganizationAccountAccessRole"
            },
            "production": {
              "account_id": "${{ needs.validate-inputs.outputs.prod_account_id }}",
              "role_name": "OrganizationAccountAccessRole"
            }
          }
          EOF
          
          # Copy shared backend configurations (if they exist)
          if [ -d "../base-repo/shared" ]; then
            mkdir -p shared
            # Copy all files from shared directory
            cp -r ../base-repo/shared/* shared/ 2>/dev/null || echo "âš ï¸ No files found in shared directory"
            echo "âœ… Copied all shared configuration files from base repository"
            
            # Update backend configurations with account IDs (if files exist)
            if [ -f "shared/backend-dev.hcl" ]; then
              sed -i "s/REPLACE_WITH_DEV_ACCOUNT_ID/${{ needs.validate-inputs.outputs.dev_account_id }}/g" shared/backend-dev.hcl
            fi
            if [ -f "shared/backend-staging.hcl" ]; then
              sed -i "s/REPLACE_WITH_STAGING_ACCOUNT_ID/${{ needs.validate-inputs.outputs.staging_account_id }}/g" shared/backend-staging.hcl
            fi
            if [ -f "shared/backend-prod.hcl" ]; then
              sed -i "s/REPLACE_WITH_PRODUCTION_ACCOUNT_ID/${{ needs.validate-inputs.outputs.prod_account_id }}/g" shared/backend-prod.hcl
            fi
            echo "âœ… Backend configurations updated (if present)"
          else
            echo "âš ï¸ No shared directory found in base repository - skipping backend configs"
          fi
          
          # Copy scripts (if they exist)
          if [ -d "../base-repo/scripts" ]; then
            mkdir -p scripts
            # Copy all files from scripts directory
            cp -r ../base-repo/scripts/* scripts/ 2>/dev/null || echo "âš ï¸ No files found in scripts directory"
            # Make shell scripts executable
            chmod +x scripts/*.sh 2>/dev/null || echo "âš ï¸ No .sh files to make executable"
            echo "âœ… Copied all script files from base repository"
          else
            echo "âš ï¸ No scripts directory found in base repository - skipping scripts"
          fi
          
          # Copy documentation (if it exists)
          if [ -d "../base-repo/docs" ]; then
            mkdir -p docs
            # Copy all files from docs directory
            cp -r ../base-repo/docs/* docs/ 2>/dev/null || echo "âš ï¸ No files found in docs directory"
            echo "âœ… Copied all documentation files from base repository"
          else
            echo "âš ï¸ No docs directory found in base repository - skipping docs"
          fi
          
          # Copy GitHub workflows (including build and destroy workflows)
          mkdir -p .github/workflows
          if [ -d "../base-repo/.github/workflows" ]; then
            cp ../base-repo/.github/workflows/*.yml .github/workflows/
            echo "âœ… Copied GitHub workflows from base repository"
          else
            echo "âš ï¸ No workflows directory found in base repository"
          fi
          
          # Create tfvars directory with examples
          mkdir -p tfvars
          cat > tfvars/README.md << 'EOF'
          # Terraform Variables Configuration

          This directory contains environment-specific configuration files for your infrastructure.

          ## ðŸ“‹ Required Files

          You need to create the following files with your specific configurations:

          - `dev-terraform.tfvars` - Development environment configuration
          - `stg-terraform.tfvars` - Staging environment configuration  
          - `prod-terraform.tfvars` - Production environment configuration

          ## ðŸš€ Getting Started

          1. Copy the example files and remove the `.example` extension
          2. Update the values according to your requirements
          3. Commit the files to your repository
          4. Push to dev branch to trigger deployment

          ## ðŸ”’ Security Note

          These files may contain sensitive information. Ensure your repository is private and follow your organization's security guidelines.
          EOF

                    # Create example tfvars files
                    cat > tfvars/dev-terraform.tfvars.example << EOF
          # Development Environment Configuration
          project_name = "${{ needs.validate-inputs.outputs.app_name }}"
          environment = "dev"
          account_id = "${{ needs.validate-inputs.outputs.dev_account_id }}"
          aws_region = "${{ needs.validate-inputs.outputs.aws_region }}"

          # GitLab configuration for private modules
          gitlab_org = "your-gitlab-org"

          # Base modules configuration
          base_modules = {
            ec2 = {
              repository = "ec2-base-module"
              version    = "main"
            }
            alb = {
              repository = "alb-base-module"
              version    = "main"
            }
          }

          # ALB Configuration
          alb_spec = {
            web-alb = {
              vpc_name = "dev-vpc"
              http_enabled = true
              https_enabled = false
              name = "web-alb"
            }
          }

          # EC2 Configuration
          ec2_spec = {
            "web-server" = {
              enable_alb_integration = true
              alb_name = "web-alb"
              instance_type = "t3.micro"
              vpc_name = "dev-vpc"
              subnet_name = "dev-public-subnet-1"
              ami_name = "amzn2-ami-hvm-*-x86_64-gp2"
              os_type = "linux"
              root_volume_size = 20
              key_name = "your-key-pair"
            }
          }
          EOF

                    # Create staging and production examples
                    sed 's/dev/staging/g; s/t3.micro/t3.small/g; s/20/30/g' tfvars/dev-terraform.tfvars.example > tfvars/stg-terraform.tfvars.example
                    sed -i "s/${{ needs.validate-inputs.outputs.dev_account_id }}/${{ needs.validate-inputs.outputs.staging_account_id }}/g" tfvars/stg-terraform.tfvars.example
                    
                    sed 's/dev/prod/g; s/staging/prod/g; s/t3.small/t3.medium/g; s/30/50/g; s/false/true/g' tfvars/stg-terraform.tfvars.example > tfvars/prod-terraform.tfvars.example
                    sed -i "s/${{ needs.validate-inputs.outputs.staging_account_id }}/${{ needs.validate-inputs.outputs.prod_account_id }}/g" tfvars/prod-terraform.tfvars.example

                    # Create userdata directory with examples
                    mkdir -p userdata
                    cat > userdata/README.md << 'EOF'
          # User Data Scripts

          This directory contains server initialization scripts that run when your EC2 instances start.

          ## ðŸ“‹ Required Files

          You need to create the following files based on your operating system requirements:

          - `userdata-linux.sh` - Linux server initialization script
          - `userdata-windows.ps1` - Windows server initialization script (if needed)

          ## ðŸš€ Getting Started

          1. Copy the example files and remove the `.example` extension
          2. Customize the scripts for your application requirements
          3. Test the scripts in development environment first
          4. Commit the files to your repository
          EOF

                    # Create example userdata files
                    cat > userdata/userdata-linux.sh.example << 'EOF'
          #!/bin/bash

          # Linux Server Initialization Script
          # This script runs when your EC2 instance starts

          # Variables passed from Terraform
          ENVIRONMENT="${environment}"
          HOSTNAME="${hostname}"
          OS_TYPE="${os_type}"

          # Set hostname
          hostnamectl set-hostname "$HOSTNAME"

          # Update system
          yum update -y

          # Install basic packages
          yum install -y \
              curl \
              wget \
              unzip \
              git \
              htop \
              awscli

          # Install Docker (example)
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          usermod -a -G docker ec2-user

          # Configure application for environment
          case "$ENVIRONMENT" in
              "dev")
                  echo "Configuring for development environment"
                  ;;
              "staging")
                  echo "Configuring for staging environment"
                  ;;
              "prod")
                  echo "Configuring for production environment"
                  ;;
          esac

          # Log completion
          echo "User data script completed for $HOSTNAME in $ENVIRONMENT environment" >> /var/log/userdata.log
          EOF

                    # Create dev-specific README
                    cat > README.md << EOF
          # ${{ needs.validate-inputs.outputs.app_name }} Infrastructure - Development Branch

          This is the development branch containing all infrastructure configuration files.

          ## ðŸ—ï¸ Architecture

          - **Development**: Account ID ${{ needs.validate-inputs.outputs.dev_account_id }}
          - **Staging**: Account ID ${{ needs.validate-inputs.outputs.staging_account_id }}  
          - **Production**: Account ID ${{ needs.validate-inputs.outputs.prod_account_id }}

          ## ðŸš€ Quick Start

          ### 1. Configure Your Infrastructure

          \`\`\`bash
          # Copy example files and customize
          cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars
          cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars
          cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars
          \`\`\`

          ### 2. Add User Data Scripts

          \`\`\`bash
          cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh
          # Edit scripts for your application
          \`\`\`

          ### 3. Deploy with GitOps

          \`\`\`bash
          git add .
          git commit -m "feat: configure infrastructure"
          git push origin dev
          \`\`\`

          ## ðŸŒ GitOps Workflow

          - **Dev**: Auto-deploys on push to dev branch
          - **Staging**: Create PR from dev â†’ staging (requires approval from: ${{ needs.validate-inputs.outputs.staging_approvers }})
          - **Production**: Create PR from staging â†’ production (requires approval from: ${{ needs.validate-inputs.outputs.prod_approvers }})

          ---
          Generated by Platform Engineering Pipeline
          EOF
          
          # Show what was created in dev branch
          echo "ðŸ“‹ Dev branch contents:"
          ls -la
          echo ""
          echo "ðŸ“ Directories created:"
          find . -type d -name ".*" -prune -o -type d -print | sort
          echo ""
          echo "ðŸ“„ Key files created:"
          find . -name "*.tf" -o -name "*.example" -o -name "README.md" -o -name "*.yml" | head -10
          
          # Commit all configuration files to dev branch
          git add .
          git commit -m "feat: add infrastructure configuration files

            - Add Terraform infrastructure files (main.tf, variables.tf, outputs.tf)
            - Add environment-specific tfvars examples
            - Add userdata script examples
            - Add AWS account configurations
            - Add backend configurations for all environments
            - Add deployment scripts and documentation
            - Add GitHub workflows for build and destroy

          Ready for app team configuration and deployment."

          # Push dev branch
          git push -u origin dev
          echo "âœ… Created dev branch with all configuration files"
          
      - name: Create empty staging and production branches
        run: |
          cd target-repo
          
          # Create empty staging branch from main (not dev)
          git checkout main
          git checkout -b staging
          git push -u origin staging
          echo "âœ… Created empty staging branch (content comes via PR from dev)"
          
          # Create empty production branch from main (not staging)
          git checkout main
          git checkout -b production  
          git push -u origin production
          echo "âœ… Created empty production branch (content comes via PR from staging)"

      - name: Setup GitHub environments
        run: |
          REPO_FULL_NAME="${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          
          # Create dev environment (no protection)
          gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/environments/dev" \
            --input - << EOF
          {
            "deployment_branch_policy": {
              "protected_branches": false,
              "custom_branch_policies": true
            }
          }
          EOF
          echo "âœ… Created dev environment"
          
          # Create staging environment with reviewers (for both build and destroy)
          echo "Creating staging environment with reviewers: ${{ needs.validate-inputs.outputs.staging_approvers }}"
          STAGING_REVIEWERS='[{"type": "User", "id": null}]'  # Simplified for now
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/environments/staging" \
            --input - << EOF 2>/dev/null
          {
            "deployment_branch_policy": {
              "protected_branches": false,
              "custom_branch_policies": true
            }
          }
          EOF
          then
            echo "âœ… Created staging environment"
            echo "   - Manual approval setup required in GitHub UI for: ${{ needs.validate-inputs.outputs.staging_approvers }}"
          else
            echo "âŒ Failed to create staging environment"
          fi
          
          # Create production environment with reviewers (for both build and destroy)
          echo "Creating production environment with reviewers: ${{ needs.validate-inputs.outputs.prod_approvers }}"
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/environments/production" \
            --input - << EOF 2>/dev/null
          {
            "deployment_branch_policy": {
              "protected_branches": false,
              "custom_branch_policies": true
            }
          }
          EOF
          then
            echo "âœ… Created production environment"
            echo "   - Manual approval setup required in GitHub UI for: ${{ needs.validate-inputs.outputs.prod_approvers }}"
          else
            echo "âŒ Failed to create production environment"
          fi
          
      - name: Setup branch protection rules
        run: |
          REPO_FULL_NAME="${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}"
          
          # Try to protect staging branch (requires GitHub Pro for private repos)
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/branches/staging/protection" \
            --input - << 'EOF' 2>/dev/null
          {
            "required_status_checks": null,
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "required_approving_review_count": 1,
              "dismiss_stale_reviews": true,
              "require_code_owner_reviews": false
            },
            "restrictions": null
          }
          EOF
          then
            echo "âœ… Protected staging branch"
          else
            echo "âš ï¸ Branch protection not available - requires GitHub Pro for private repos"
            echo "   Manual setup: Go to Settings â†’ Branches â†’ Add rule for 'staging'"
          fi
          
          # Try to protect production branch (requires GitHub Pro for private repos)
          if gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/$REPO_FULL_NAME/branches/production/protection" \
            --input - << 'EOF' 2>/dev/null
          {
            "required_status_checks": null,
            "enforce_admins": false,
            "required_pull_request_reviews": {
              "required_approving_review_count": 2,
              "dismiss_stale_reviews": true,
              "require_code_owner_reviews": false
            },
            "restrictions": null
          }
          EOF
          then
            echo "âœ… Protected production branch"
          else
            echo "âš ï¸ Branch protection not available - requires GitHub Pro for private repos"
            echo "   Manual setup: Go to Settings â†’ Branches â†’ Add rule for 'production'"
          fi

  notify-completion:
    name: Notify App Team
    runs-on: ubuntu-latest
    needs: [validate-inputs, create-repository, setup-repository-structure, setup-gitops-workflow]
    if: always()
    
    steps:
      - name: Create summary
        run: |
          if [[ "${{ needs.setup-gitops-workflow.result }}" == "success" ]]; then
            echo "## âœ… Infrastructure Repository Created Successfully" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Repository:** [${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Branch Structure:**" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ  **Main**: README and workflows only" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ”§ **Dev**: All configuration files and examples (auto-deploy)" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ§ª **Staging**: Ready for staging deployments (requires approval)" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸš€ **Production**: Ready for production deployments (requires approval)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment Setup:**" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ”§ **Dev**: Ready for auto-deployment" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ§ª **Staging**: Environment created - add reviewers manually: ${{ needs.validate-inputs.outputs.staging_approvers }}" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸš€ **Production**: Environment created - add reviewers manually: ${{ needs.validate-inputs.outputs.prod_approvers }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Manual Setup Required:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Go to repository Settings â†’ Environments" >> $GITHUB_STEP_SUMMARY
            echo "2. Configure reviewers for staging and production environments" >> $GITHUB_STEP_SUMMARY
            echo "3. Enable 'Prevent self-review' if desired" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps for App Team:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Clone repository: \`git clone https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Switch to dev branch: \`git checkout dev\`" >> $GITHUB_STEP_SUMMARY
            echo "3. Configure tfvars and userdata files" >> $GITHUB_STEP_SUMMARY
            echo "4. Set up AWS credentials in GitHub secrets" >> $GITHUB_STEP_SUMMARY
            echo "5. Push to dev branch to start deployment" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Infrastructure Repository Creation Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Prepare notification for app team
        if: always()
        run: |
          echo "## ðŸ“§ App Team Notification Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Please forward this workflow summary to the app team:** ${{ github.event.inputs.app_team_contacts || github.event.client_payload.app_team_contacts }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# ðŸ“‹ Infrastructure Repository Setup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Hello App Team! ðŸ‘‹" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Your infrastructure repository has been created and is ready for use." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ—ï¸ Repository Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: [${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }})" >> $GITHUB_STEP_SUMMARY
          echo "- **App Name**: ${{ needs.validate-inputs.outputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Created by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Accounts**: Dev(${{ needs.validate-inputs.outputs.dev_account_id }}), Staging(${{ needs.validate-inputs.outputs.staging_account_id }}), Prod(${{ needs.validate-inputs.outputs.prod_account_id }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸš€ Quick Start Guide" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 1. Clone and Setup" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Clone your repository" >> $GITHUB_STEP_SUMMARY
          echo "git clone https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git" >> $GITHUB_STEP_SUMMARY
          echo "cd ${{ needs.validate-inputs.outputs.repo_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Switch to dev branch (where all your config files are)" >> $GITHUB_STEP_SUMMARY
          echo "git checkout dev" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 2. Configure Your Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Copy example files and customize them" >> $GITHUB_STEP_SUMMARY
          echo "cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars" >> $GITHUB_STEP_SUMMARY
          echo "cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars" >> $GITHUB_STEP_SUMMARY
          echo "cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Copy userdata scripts and customize" >> $GITHUB_STEP_SUMMARY
          echo "cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 3. Set Up GitHub Secrets" >> $GITHUB_STEP_SUMMARY
          echo "Go to your repository Settings â†’ Secrets and variables â†’ Actions, and add:" >> $GITHUB_STEP_SUMMARY
          echo "- \`AWS_ACCESS_KEY_ID\` - Your AWS access key" >> $GITHUB_STEP_SUMMARY
          echo "- \`AWS_SECRET_ACCESS_KEY\` - Your AWS secret key" >> $GITHUB_STEP_SUMMARY
          echo "- \`PRIVATE_REPO_TOKEN\` - GitHub token for private modules (if needed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 4. Deploy Your Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Commit your changes" >> $GITHUB_STEP_SUMMARY
          echo "git add ." >> $GITHUB_STEP_SUMMARY
          echo "git commit -m \"feat: configure infrastructure for ${{ needs.validate-inputs.outputs.app_name }}\"" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Push to dev branch (triggers automatic deployment)" >> $GITHUB_STEP_SUMMARY
          echo "git push origin dev" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸŒ GitOps Workflow" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev**: Auto-deploys when you push to dev branch" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging**: Create PR from dev â†’ staging (requires approval from: ${{ needs.validate-inputs.outputs.staging_approvers }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Production**: Create PR from staging â†’ production (requires approval from: ${{ needs.validate-inputs.outputs.prod_approvers }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“– Documentation" >> $GITHUB_STEP_SUMMARY
          echo "- [README.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/main/README.md) - Project overview" >> $GITHUB_STEP_SUMMARY
          echo "- [SETUP.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/main/SETUP.md) - Detailed setup guide" >> $GITHUB_STEP_SUMMARY
          echo "- [tfvars/README.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/dev/tfvars/README.md) - Configuration guide" >> $GITHUB_STEP_SUMMARY
          echo "- [userdata/README.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/dev/userdata/README.md) - Script guide" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ†˜ Need Help?" >> $GITHUB_STEP_SUMMARY
          echo "- Check the documentation links above" >> $GITHUB_STEP_SUMMARY
          echo "- Contact Platform Engineering team" >> $GITHUB_STEP_SUMMARY
          echo "- View this workflow run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Happy coding! ðŸš€" >> $GITHUB_STEP_SUMMARY
          
      - name: Create notification issue for app team
        if: always() && needs.setup-gitops-workflow.result == 'success'
        run: |
          # Extract GitHub usernames from email addresses (if they follow email@github-username pattern)
          APP_CONTACTS="${{ github.event.inputs.app_team_contacts || github.event.client_payload.app_team_contacts }}"
          
          # Create an issue in the new repository to notify the app team
          ISSUE_BODY=$(cat << 'ISSUE_EOF'
          Hello App Team! ðŸ‘‹

          Your infrastructure repository has been created and is ready for use.

          ## ðŸ—ï¸ Repository Details
          - **Repository**: [${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }})
          - **App Name**: ${{ needs.validate-inputs.outputs.app_name }}
          - **Created by**: ${{ github.actor }}
          - **AWS Accounts**: Dev(${{ needs.validate-inputs.outputs.dev_account_id }}), Staging(${{ needs.validate-inputs.outputs.staging_account_id }}), Prod(${{ needs.validate-inputs.outputs.prod_account_id }})

          ## ðŸš€ Quick Start Guide

          ### 1. Clone and Setup
          ```bash
          # Clone your repository
          git clone https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}.git
          cd ${{ needs.validate-inputs.outputs.repo_name }}

          # Switch to dev branch (where all your config files are)
          git checkout dev
          ```

          ### 2. Configure Your Infrastructure
          ```bash
          # Copy example files and customize them
          cp tfvars/dev-terraform.tfvars.example tfvars/dev-terraform.tfvars
          cp tfvars/stg-terraform.tfvars.example tfvars/stg-terraform.tfvars
          cp tfvars/prod-terraform.tfvars.example tfvars/prod-terraform.tfvars

          # Copy userdata scripts and customize
          cp userdata/userdata-linux.sh.example userdata/userdata-linux.sh
          ```

          ### 3. Set Up GitHub Secrets
          Go to your repository Settings â†’ Secrets and variables â†’ Actions, and add:
          - `AWS_ACCESS_KEY_ID` - Your AWS access key
          - `AWS_SECRET_ACCESS_KEY` - Your AWS secret key
          - `PRIVATE_REPO_TOKEN` - GitHub token for private modules (if needed)

          ### 4. Deploy Your Infrastructure
          ```bash
          # Commit your changes
          git add .
          git commit -m "feat: configure infrastructure for ${{ needs.validate-inputs.outputs.app_name }}"

          # Push to dev branch (triggers automatic deployment)
          git push origin dev
          ```

          ## ðŸŒ GitOps Workflow
          - **Dev**: Auto-deploys when you push to dev branch
          - **Staging**: Create PR from dev â†’ staging (requires approval from: ${{ needs.validate-inputs.outputs.staging_approvers }})
          - **Production**: Create PR from staging â†’ production (requires approval from: ${{ needs.validate-inputs.outputs.prod_approvers }})

          ## ðŸ“– Documentation
          - [README.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/main/README.md) - Project overview
          - [SETUP.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/main/SETUP.md) - Detailed setup guide
          - [tfvars/README.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/dev/tfvars/README.md) - Configuration guide
          - [userdata/README.md](https://github.com/${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}/blob/dev/userdata/README.md) - Script guide

          ## ðŸ†˜ Need Help?
          - Check the documentation links above
          - Contact Platform Engineering team
          - Comment on this issue for questions

          **Platform Engineering Team**  
          Repository created via workflow: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ---
          Please close this issue once you've completed the setup. Happy coding! ðŸš€
          ISSUE_EOF
          )
          
          gh issue create \
            --repo "${{ needs.validate-inputs.outputs.target_org }}/${{ needs.validate-inputs.outputs.repo_name }}" \
            --title "ðŸŽ‰ Your Infrastructure Repository is Ready!" \
            --body "$ISSUE_BODY" \
            --label "setup,platform-engineering"
          
          echo "âœ… Created notification issue in the new repository"
